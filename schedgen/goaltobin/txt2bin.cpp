/* Generated by re2c 1.3 on Wed Oct 26 16:11:55 2022 */
#line 1 "txt2bin.re"
#include <map>
#include <math.h>
#include <string>
#include <limits>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <inttypes.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/types.h>

#include "Goal.hpp"
#include "cmdline_txt2bin.h"

typedef unsigned int uint;
typedef unsigned char uchar;

#define	BSIZE	10240

#define	YYCTYPE		uchar
#define	YYCURSOR	cursor
#define	YYLIMIT		s->lim
#define	YYMARKER	s->ptr
#define	YYFILL(n)	{cursor = fill(s, cursor, n);}

#define	RET(i)	{s->cur = cursor; return i;}

gengetopt_args_info args_info;

typedef struct Scanner {
    FILE*		fd;
    uchar		*bot, *tok, *ptr, *cur, *pos, *lim, *top, *eof;
    uint		line;
	int			rank;
	uint32_t 	curr_rank, num_ranks;
	Goal*		schedule;
	std::map<std::string, goalop_t>* idtbl;
} Scanner;

typedef struct Item {
	char type;
	char *label1;
	char *label2;
	uint64_t size;
	uint32_t target;
	uint32_t tag;
	uint8_t cpu;
	uint8_t nic;	
} Item;

enum OpTypes {
	Undefined,
	SendOp,
	RecvOp,
	LoclOp,
	StartDependency,
	Dependency
};

inline uint64_t add_number(unsigned char *s, unsigned char *e) {

	uint64_t num = 0;	
	--s;
	while(++s < e) num = num * 10 + (*s - '0');

	return num;
}

inline void insert_id(Scanner *s, char *id, goalop_t op) {

	s->idtbl->insert(std::make_pair(std::string(id), op));
	free(id);
}

inline goalop_t retrieve_id(Scanner *s, char *id) {

	std::map<std::string, goalop_t>::iterator it;
	it = s->idtbl->find(std::string(id));
	if (it == s->idtbl->end()) {
		fprintf(stderr, "A dependency references label %s, which is undefined!\n", id);
		exit(EXIT_FAILURE);
	}
	free(id);
	return it->second;
} 

void process_item(Scanner *s, Item *item) {

/*
	printf("Parsed Item:\n");
	printf("  Type: ");
	if (item->type == Undefined) printf("Undefined\n");
	if (item->type == SendOp) printf("Send\n");
	if (item->type == RecvOp) printf("Recv\n");
	if (item->type == LoclOp) printf("LoclOp\n");
	if (item->type == StartDependency) printf("IRequires\n");
	if (item->type == Dependency) printf("Requires\n");
	printf("  Label1: %s\n", item->label1);
	printf("  Label2: %s\n", item->label2);
	printf("  Size: %i\n", item->size);
	printf("  Target: %i\n", item->target);
	printf("  Tag: %i\n", item->tag);
	printf("  CPU: %i\n", item->cpu);
	printf("  NIC: %i\n", item->nic);
*/
	
	goalop_t op, op2;

	switch (item->type) {
		case Undefined:
			fprintf(stderr, "Error while parsing, attempt to add a undefined operation\n");
			exit(EXIT_FAILURE);
			break;
		case SendOp:
			op = s->schedule->Send(s->rank, item->target, item->size, item->tag, item->cpu, item->nic);
			if (item->label1 != NULL) insert_id(s, item->label1, op);
			break;
		case RecvOp:
			op = s->schedule->Recv(item->target, s->rank, item->size, item->tag, item->cpu, item->nic);
			if (item->label1 != NULL) insert_id(s, item->label1, op);
			break;
		case LoclOp:
			op = s->schedule->Calc(s->rank, item->size, item->cpu, item->nic);
			if (item->label1 != NULL) insert_id(s, item->label1, op);
			break;
		case StartDependency:
			op = retrieve_id(s, item->label1);
			op2 = retrieve_id(s, item->label2);
			assert(op != NULL);
			assert(op2 != NULL);
			s->schedule->StartDependency(op, op2);
			break;
		case Dependency:
			op = retrieve_id(s, item->label1);
			op2 = retrieve_id(s, item->label2);
			assert(op != NULL);
			assert(op2 != NULL);
			s->schedule->Dependency(op, op2);
			break;
		default:
			break;
	}
}

inline char* add_label(unsigned char *s, unsigned char *e) {
	
	char *buf = NULL;

	buf = (char *) malloc((e-s)+1);
	memcpy((void *) buf, (void *) s, (size_t) (e-s));
	buf[e-s] = '\0';
	
	return buf;

}


uchar *fill(Scanner *s, uchar *cursor, int numtoread) {

	if(!s->eof) {
		uint cnt = s->tok - s->bot;
		if(cnt){
			if ((s->lim - s->tok) < abs(s->bot - s->tok)) memcpy(s->bot, s->tok, s->lim - s->tok);
			else memmove(s->bot, s->tok, s->lim - s->tok);
			s->tok = s->bot;
			s->ptr -= cnt;
			cursor -= cnt;
			s->pos -= cnt;
			s->lim -= cnt;
		}
		if((s->top - s->lim) < BSIZE){
			uchar *buf = (uchar*) malloc(((s->lim - s->bot) + BSIZE)*sizeof(uchar));
			if ((s->lim - s->tok) > abs(s->tok - buf)) memmove(buf, s->tok, s->lim - s->tok);
			else memcpy(buf, s->tok, s->lim - s->tok);
			s->tok = buf;
			s->ptr = &buf[s->ptr - s->bot];
			cursor = &buf[cursor - s->bot];
			s->pos = &buf[s->pos - s->bot];
			s->lim = &buf[s->lim - s->bot];
			s->top = &s->lim[BSIZE];
			free(s->bot);
			s->bot = buf;
		}
		cnt = fread((char*) s->lim, 1, BSIZE, s->fd);
		if(cnt != BSIZE) { 
			s->eof = &s->lim[cnt];
			*(s->eof)++ = '\n';
		}
		s->lim += cnt;
		//assert(cnt >= numtoread);
	}
	return cursor;
}

/*
uchar *fill(Scanner *s, uchar *cursor, int numtoread) {
	
	static bool firstcall = true;

	if (firstcall) {
		
		void *buf;
		struct stat statbuf;
		
		int ret = fstat(fileno(s->fd), &statbuf);
		buf = mmap(NULL, statbuf.st_size, PROT_READ, MAP_PRIVATE, fileno(s->fd), 0);
		assert(buf != NULL);
		s->lim = (uchar*) buf;
		s->lim += statbuf.st_size;
		s->eof = s->lim;
		return (uchar*) buf;	   		
	}
	else {
		assert(0==1);
	}
}
*/

int scan(Scanner *s) {

	//uchar *cursor = s->cur;

	static uchar *cursor = NULL;
	Item item;
	int state;

	for (;;) {

s_0:

	if ((cursor == s->eof) and (cursor != NULL)) {
		fprintf(stderr, "Reached the end of the inputfile - did you forget a closing bracket?\n");
		return s->rank;
	}
	
	s->tok = cursor;
	state = 0;
	
	// printf("Entered s_0\n");
	// if (((s->line % 100) == 0) or (s->line < 100)) printf("Line: %i\n", s->line);

	item.type = Undefined;
	item.label1 = NULL;
	item.label2 = NULL;
	item.cpu = 0;
	item.nic = 0;
	item.tag = 0;


#line 256 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 10) YYFILL(10);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy4;
			case '\n':	goto yy7;
			case '\r':	goto yy9;
			case '/':	goto yy10;
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case 'a':
			case 'b':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'o':
			case 'p':
			case 'q':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			case 'c':	goto yy14;
			case 'n':	goto yy15;
			case 'r':	goto yy16;
			case 's':	goto yy17;
			case '}':	goto yy18;
			default:	goto yy2;
			}
yy2:
			++YYCURSOR;
yy3:
#line 294 "txt2bin.re"
			{ goto s_err; }
#line 327 "txt2bin.cpp"
yy4:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy4;
			default:	goto yy6;
			}
yy6:
#line 282 "txt2bin.re"
			{ s->tok = cursor; }
#line 340 "txt2bin.cpp"
yy7:
			++YYCURSOR;
#line 292 "txt2bin.re"
			{ s->line++; continue; }
#line 345 "txt2bin.cpp"
yy9:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy7;
			default:	goto yy3;
			}
yy10:
			yych = *++YYCURSOR;
			switch (yych) {
			case '*':	goto yy20;
			case '/':	goto yy22;
			default:	goto yy3;
			}
yy11:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy12:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			default:	goto yy13;
			}
yy13:
#line 288 "txt2bin.re"
			{ item.label1 = add_label(s->tok, cursor); goto s_1; }
#line 433 "txt2bin.cpp"
yy14:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'a':	goto yy24;
			default:	goto yy12;
			}
yy15:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy25;
			default:	goto yy12;
			}
yy16:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'a':	goto yy26;
			case 'e':	goto yy27;
			default:	goto yy12;
			}
yy17:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy28;
			default:	goto yy12;
			}
yy18:
			++YYCURSOR;
#line 293 "txt2bin.re"
			{ if (s->rank == -1) goto s_err; int oldrank = s->rank; s->rank = -1; return oldrank; }
#line 463 "txt2bin.cpp"
yy20:
			++YYCURSOR;
#line 290 "txt2bin.re"
			{ goto s_24; }
#line 468 "txt2bin.cpp"
yy22:
			++YYCURSOR;
#line 289 "txt2bin.re"
			{ goto s_23; }
#line 473 "txt2bin.cpp"
yy24:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy29;
			default:	goto yy12;
			}
yy25:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'm':	goto yy30;
			default:	goto yy12;
			}
yy26:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy31;
			default:	goto yy12;
			}
yy27:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy32;
			default:	goto yy12;
			}
yy28:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy33;
			default:	goto yy12;
			}
yy29:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy34;
			default:	goto yy12;
			}
yy30:
			yych = *++YYCURSOR;
			switch (yych) {
			case '_':	goto yy36;
			default:	goto yy12;
			}
yy31:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'k':	goto yy37;
			default:	goto yy12;
			}
yy32:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'v':	goto yy39;
			default:	goto yy12;
			}
yy33:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'd':	goto yy41;
			default:	goto yy12;
			}
yy34:
			yych = *++YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			default:	goto yy35;
			}
yy35:
#line 285 "txt2bin.re"
			{ item.type = LoclOp;  goto s_3; }
#line 605 "txt2bin.cpp"
yy36:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy43;
			default:	goto yy12;
			}
yy37:
			yych = *++YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			default:	goto yy38;
			}
yy38:
#line 286 "txt2bin.re"
			{ goto s_20; }
#line 683 "txt2bin.cpp"
yy39:
			yych = *++YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			default:	goto yy40;
			}
yy40:
#line 284 "txt2bin.re"
			{ item.type = RecvOp;  goto s_2; }
#line 755 "txt2bin.cpp"
yy41:
			yych = *++YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			default:	goto yy42;
			}
yy42:
#line 283 "txt2bin.re"
			{ item.type = SendOp;  goto s_2; }
#line 827 "txt2bin.cpp"
yy43:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'a':	goto yy44;
			default:	goto yy12;
			}
yy44:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy45;
			default:	goto yy12;
			}
yy45:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'k':	goto yy46;
			default:	goto yy12;
			}
yy46:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy47;
			default:	goto yy12;
			}
yy47:
			yych = *++YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy11;
			default:	goto yy48;
			}
yy48:
#line 287 "txt2bin.re"
			{ goto s_22; }
#line 923 "txt2bin.cpp"
		}
#line 295 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_1:
	state =1;

	// printf("Entered s_1\n");


#line 936 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 9) YYFILL(9);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy53;
			case ':':	goto yy56;
			case 'i':	goto yy58;
			case 'r':	goto yy59;
			default:	goto yy51;
			}
yy51:
			++YYCURSOR;
yy52:
#line 309 "txt2bin.re"
			{ goto s_err; }
#line 954 "txt2bin.cpp"
yy53:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy53;
			default:	goto yy55;
			}
yy55:
#line 305 "txt2bin.re"
			{ goto s_1; }
#line 967 "txt2bin.cpp"
yy56:
			++YYCURSOR;
#line 306 "txt2bin.re"
			{ goto s_4; }
#line 972 "txt2bin.cpp"
yy58:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'r':	goto yy60;
			default:	goto yy52;
			}
yy59:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'e':	goto yy62;
			default:	goto yy52;
			}
yy60:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy63;
			default:	goto yy61;
			}
yy61:
			YYCURSOR = YYMARKER;
			goto yy52;
yy62:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'q':	goto yy64;
			default:	goto yy61;
			}
yy63:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'q':	goto yy65;
			default:	goto yy61;
			}
yy64:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy66;
			default:	goto yy61;
			}
yy65:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy67;
			default:	goto yy61;
			}
yy66:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'i':	goto yy68;
			default:	goto yy61;
			}
yy67:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'i':	goto yy69;
			default:	goto yy61;
			}
yy68:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy70;
			default:	goto yy61;
			}
yy69:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'r':	goto yy71;
			default:	goto yy61;
			}
yy70:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy72;
			default:	goto yy61;
			}
yy71:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':	goto yy73;
			default:	goto yy61;
			}
yy72:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy74;
			default:	goto yy61;
			}
yy73:
			yych = *++YYCURSOR;
			switch (yych) {
			case 's':	goto yy76;
			default:	goto yy61;
			}
yy74:
			++YYCURSOR;
#line 307 "txt2bin.re"
			{ item.type = Dependency;       goto s_5; }
#line 1070 "txt2bin.cpp"
yy76:
			++YYCURSOR;
#line 308 "txt2bin.re"
			{ item.type = StartDependency;  goto s_5; }
#line 1075 "txt2bin.cpp"
		}
#line 310 "txt2bin.re"

	assert(0==1); //We should never reach this line

s_2:
	state=2;

	// printf("Entered s_2\n");

		s->tok = cursor;

#line 1088 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy82;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy85;
			default:	goto yy80;
			}
yy80:
			++YYCURSOR;
#line 322 "txt2bin.re"
			{ goto s_err; }
#line 1112 "txt2bin.cpp"
yy82:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy82;
			default:	goto yy84;
			}
yy84:
#line 320 "txt2bin.re"
			{ goto s_2; }
#line 1125 "txt2bin.cpp"
yy85:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy85;
			default:	goto yy87;
			}
yy87:
#line 321 "txt2bin.re"
			{ item.size = add_number(s->tok, cursor); goto s_10; }
#line 1146 "txt2bin.cpp"
		}
#line 323 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_3:
	state = 3;
	// printf("Entered s_3\n");

		s->tok = cursor;

#line 1159 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy92;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy95;
			default:	goto yy90;
			}
yy90:
			++YYCURSOR;
#line 335 "txt2bin.re"
			{ goto s_err; }
#line 1183 "txt2bin.cpp"
yy92:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy92;
			default:	goto yy94;
			}
yy94:
#line 333 "txt2bin.re"
			{ goto s_3; }
#line 1196 "txt2bin.cpp"
yy95:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy95;
			default:	goto yy97;
			}
yy97:
#line 334 "txt2bin.re"
			{ item.size = add_number(s->tok, cursor); goto s_7; }
#line 1217 "txt2bin.cpp"
		}
#line 336 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_4:
	state = 4;
	// printf("Entered s_4\n");


#line 1229 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy102;
			case 'c':	goto yy105;
			case 'r':	goto yy106;
			case 's':	goto yy107;
			default:	goto yy100;
			}
yy100:
			++YYCURSOR;
yy101:
#line 349 "txt2bin.re"
			{ goto s_err; }
#line 1247 "txt2bin.cpp"
yy102:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy102;
			default:	goto yy104;
			}
yy104:
#line 345 "txt2bin.re"
			{ goto s_4; }
#line 1260 "txt2bin.cpp"
yy105:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'a':	goto yy108;
			default:	goto yy101;
			}
yy106:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'e':	goto yy110;
			default:	goto yy101;
			}
yy107:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'e':	goto yy111;
			default:	goto yy101;
			}
yy108:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':	goto yy112;
			default:	goto yy109;
			}
yy109:
			YYCURSOR = YYMARKER;
			goto yy101;
yy110:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy113;
			default:	goto yy109;
			}
yy111:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'n':	goto yy114;
			default:	goto yy109;
			}
yy112:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy115;
			default:	goto yy109;
			}
yy113:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'v':	goto yy117;
			default:	goto yy109;
			}
yy114:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'd':	goto yy119;
			default:	goto yy109;
			}
yy115:
			++YYCURSOR;
#line 346 "txt2bin.re"
			{ item.type = LoclOp; goto s_3; }
#line 1322 "txt2bin.cpp"
yy117:
			++YYCURSOR;
#line 348 "txt2bin.re"
			{ item.type = RecvOp; goto s_2; }
#line 1327 "txt2bin.cpp"
yy119:
			++YYCURSOR;
#line 347 "txt2bin.re"
			{ item.type = SendOp; goto s_2; }
#line 1332 "txt2bin.cpp"
		}
#line 350 "txt2bin.re"

	assert(0==1); //We should never reach this line

s_5:
	state =5;
	// printf("Entered s_5\n");

		s->tok = cursor;

#line 1344 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy125;
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy128;
			default:	goto yy123;
			}
yy123:
			++YYCURSOR;
#line 361 "txt2bin.re"
			{ goto s_err; }
#line 1410 "txt2bin.cpp"
yy125:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy125;
			default:	goto yy127;
			}
yy127:
#line 359 "txt2bin.re"
			{ goto s_5; }
#line 1423 "txt2bin.cpp"
yy128:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy128;
			default:	goto yy130;
			}
yy130:
#line 360 "txt2bin.re"
			{ item.label2 = add_label(s->tok, cursor); goto s_6; }
#line 1497 "txt2bin.cpp"
		}
#line 362 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_6:
	state = 6;
	// printf("Entered s_6\n");


#line 1509 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy135;
			case '\n':	goto yy138;
			case '\r':	goto yy140;
			default:	goto yy133;
			}
yy133:
			++YYCURSOR;
yy134:
#line 373 "txt2bin.re"
			{ goto s_err; }
#line 1526 "txt2bin.cpp"
yy135:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy135;
			default:	goto yy137;
			}
yy137:
#line 371 "txt2bin.re"
			{ goto s_6; }
#line 1539 "txt2bin.cpp"
yy138:
			++YYCURSOR;
#line 372 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 1544 "txt2bin.cpp"
yy140:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy138;
			default:	goto yy134;
			}
		}
#line 374 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_7:
	state = 7;
	// printf("Entered s_7\n");


#line 1562 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy145;
			case '\n':	goto yy148;
			case '\r':	goto yy150;
			case 'c':	goto yy151;
			default:	goto yy143;
			}
yy143:
			++YYCURSOR;
yy144:
#line 386 "txt2bin.re"
			{ goto s_err; }
#line 1580 "txt2bin.cpp"
yy145:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy145;
			default:	goto yy147;
			}
yy147:
#line 383 "txt2bin.re"
			{ goto s_7; }
#line 1593 "txt2bin.cpp"
yy148:
			++YYCURSOR;
#line 385 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 1598 "txt2bin.cpp"
yy150:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy148;
			default:	goto yy144;
			}
yy151:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'p':	goto yy152;
			default:	goto yy144;
			}
yy152:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy154;
			default:	goto yy153;
			}
yy153:
			YYCURSOR = YYMARKER;
			goto yy144;
yy154:
			++YYCURSOR;
#line 384 "txt2bin.re"
			{ goto s_8; }
#line 1624 "txt2bin.cpp"
		}
#line 387 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_8:
	state =8;
	// printf("Entered s_8\n");
	
	s->tok = cursor;


#line 1638 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy160;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy163;
			default:	goto yy158;
			}
yy158:
			++YYCURSOR;
#line 400 "txt2bin.re"
			{ goto s_err; }
#line 1662 "txt2bin.cpp"
yy160:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy160;
			default:	goto yy162;
			}
yy162:
#line 398 "txt2bin.re"
			{ goto s_8; }
#line 1675 "txt2bin.cpp"
yy163:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy163;
			default:	goto yy165;
			}
yy165:
#line 399 "txt2bin.re"
			{ item.cpu = add_number(s->tok, cursor); goto s_9; }
#line 1696 "txt2bin.cpp"
		}
#line 401 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_9:
	state=9;
	// printf("Entered s_9\n");


#line 1708 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy170;
			case '\n':	goto yy173;
			case '\r':	goto yy175;
			default:	goto yy168;
			}
yy168:
			++YYCURSOR;
yy169:
#line 412 "txt2bin.re"
			{ goto s_err; }
#line 1725 "txt2bin.cpp"
yy170:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy170;
			default:	goto yy172;
			}
yy172:
#line 410 "txt2bin.re"
			{ goto s_9; }
#line 1738 "txt2bin.cpp"
yy173:
			++YYCURSOR;
#line 411 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 1743 "txt2bin.cpp"
yy175:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy173;
			default:	goto yy169;
			}
		}
#line 413 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_10:
	state=10;
	// printf("Entered s_10\n");


#line 1761 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy180;
			case 'b':	goto yy183;
			default:	goto yy178;
			}
yy178:
			++YYCURSOR;
#line 424 "txt2bin.re"
			{ goto s_err; }
#line 1776 "txt2bin.cpp"
yy180:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy180;
			default:	goto yy182;
			}
yy182:
#line 422 "txt2bin.re"
			{ goto s_10; }
#line 1789 "txt2bin.cpp"
yy183:
			++YYCURSOR;
#line 423 "txt2bin.re"
			{ goto s_11; }
#line 1794 "txt2bin.cpp"
		}
#line 425 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_11:
	state = 11;
	// printf("Entered s_11\n");


#line 1806 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy189;
			case 'f':	goto yy192;
			case 't':	goto yy193;
			default:	goto yy187;
			}
yy187:
			++YYCURSOR;
yy188:
#line 437 "txt2bin.re"
			{ goto s_err; }
#line 1823 "txt2bin.cpp"
yy189:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy189;
			default:	goto yy191;
			}
yy191:
#line 434 "txt2bin.re"
			{ goto s_11; }
#line 1836 "txt2bin.cpp"
yy192:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'r':	goto yy194;
			default:	goto yy188;
			}
yy193:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy196;
			default:	goto yy188;
			}
yy194:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'o':	goto yy198;
			default:	goto yy195;
			}
yy195:
			YYCURSOR = YYMARKER;
			goto yy188;
yy196:
			++YYCURSOR;
#line 435 "txt2bin.re"
			{ if (item.type == SendOp) {goto s_12;} else {goto s_err;}; }
#line 1862 "txt2bin.cpp"
yy198:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'm':	goto yy199;
			default:	goto yy195;
			}
yy199:
			++YYCURSOR;
#line 436 "txt2bin.re"
			{ if (item.type == RecvOp) {goto s_12;} else {goto s_err;}; }
#line 1873 "txt2bin.cpp"
		}
#line 438 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_12:
	state = 12;	
	// printf("Entered s_12\n");
	
	s->tok = cursor;


#line 1887 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy205;
			case '-':	goto yy208;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy209;
			default:	goto yy203;
			}
yy203:
			++YYCURSOR;
yy204:
#line 452 "txt2bin.re"
			{ goto s_err; }
#line 1913 "txt2bin.cpp"
yy205:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy205;
			default:	goto yy207;
			}
yy207:
#line 449 "txt2bin.re"
			{ goto s_12; }
#line 1926 "txt2bin.cpp"
yy208:
			yych = *++YYCURSOR;
			switch (yych) {
			case '1':	goto yy212;
			default:	goto yy204;
			}
yy209:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy209;
			default:	goto yy211;
			}
yy211:
#line 451 "txt2bin.re"
			{ item.target = add_number(s->tok, cursor); goto s_13; }
#line 1953 "txt2bin.cpp"
yy212:
			++YYCURSOR;
#line 450 "txt2bin.re"
			{if (item.type == RecvOp) {item.target = std::numeric_limits<uint32_t>::max(); goto s_13;} else {goto s_err;}; }
#line 1958 "txt2bin.cpp"
		}
#line 453 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_13:
	state = 13;
	// printf("Entered s_13\n");


#line 1970 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy218;
			case '\n':	goto yy221;
			case '\r':	goto yy223;
			case 'c':	goto yy224;
			case 'n':	goto yy225;
			case 't':	goto yy226;
			default:	goto yy216;
			}
yy216:
			++YYCURSOR;
yy217:
#line 467 "txt2bin.re"
			{ goto s_err; }
#line 1990 "txt2bin.cpp"
yy218:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy218;
			default:	goto yy220;
			}
yy220:
#line 462 "txt2bin.re"
			{ goto s_13; }
#line 2003 "txt2bin.cpp"
yy221:
			++YYCURSOR;
#line 466 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2008 "txt2bin.cpp"
yy223:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy221;
			default:	goto yy217;
			}
yy224:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'p':	goto yy227;
			default:	goto yy217;
			}
yy225:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'i':	goto yy229;
			default:	goto yy217;
			}
yy226:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'a':	goto yy230;
			default:	goto yy217;
			}
yy227:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy231;
			default:	goto yy228;
			}
yy228:
			YYCURSOR = YYMARKER;
			goto yy217;
yy229:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy233;
			default:	goto yy228;
			}
yy230:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'g':	goto yy235;
			default:	goto yy228;
			}
yy231:
			++YYCURSOR;
#line 464 "txt2bin.re"
			{ goto s_16; }
#line 2058 "txt2bin.cpp"
yy233:
			++YYCURSOR;
#line 465 "txt2bin.re"
			{ goto s_18; }
#line 2063 "txt2bin.cpp"
yy235:
			++YYCURSOR;
#line 463 "txt2bin.re"
			{ goto s_14; }
#line 2068 "txt2bin.cpp"
		}
#line 468 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_14:
	state = 14;
	// printf("Entered s_14\n");

	s->tok = cursor;


#line 2082 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy241;
			case '-':	goto yy244;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy245;
			default:	goto yy239;
			}
yy239:
			++YYCURSOR;
yy240:
#line 482 "txt2bin.re"
			{ goto s_err; }
#line 2108 "txt2bin.cpp"
yy241:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy241;
			default:	goto yy243;
			}
yy243:
#line 479 "txt2bin.re"
			{ goto s_14; }
#line 2121 "txt2bin.cpp"
yy244:
			yych = *++YYCURSOR;
			switch (yych) {
			case '1':	goto yy248;
			default:	goto yy240;
			}
yy245:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy245;
			default:	goto yy247;
			}
yy247:
#line 481 "txt2bin.re"
			{ item.tag = add_number(s->tok, cursor); goto s_15; }
#line 2148 "txt2bin.cpp"
yy248:
			++YYCURSOR;
#line 480 "txt2bin.re"
			{ item.tag = std::numeric_limits<uint32_t>::max(); goto s_15; }
#line 2153 "txt2bin.cpp"
		}
#line 483 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_15:
	state =15;
	// printf("Entered s_15\n");


#line 2165 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy254;
			case '\n':	goto yy257;
			case '\r':	goto yy259;
			case 'c':	goto yy260;
			case 'n':	goto yy261;
			default:	goto yy252;
			}
yy252:
			++YYCURSOR;
yy253:
#line 496 "txt2bin.re"
			{ goto s_err; }
#line 2184 "txt2bin.cpp"
yy254:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy254;
			default:	goto yy256;
			}
yy256:
#line 492 "txt2bin.re"
			{ goto s_15; }
#line 2197 "txt2bin.cpp"
yy257:
			++YYCURSOR;
#line 495 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2202 "txt2bin.cpp"
yy259:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy257;
			default:	goto yy253;
			}
yy260:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'p':	goto yy262;
			default:	goto yy253;
			}
yy261:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'i':	goto yy264;
			default:	goto yy253;
			}
yy262:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'u':	goto yy265;
			default:	goto yy263;
			}
yy263:
			YYCURSOR = YYMARKER;
			goto yy253;
yy264:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy267;
			default:	goto yy263;
			}
yy265:
			++YYCURSOR;
#line 493 "txt2bin.re"
			{ goto s_16; }
#line 2240 "txt2bin.cpp"
yy267:
			++YYCURSOR;
#line 494 "txt2bin.re"
			{ goto s_18; }
#line 2245 "txt2bin.cpp"
		}
#line 497 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_16:
	state = 16;
	// printf("Entered s_16\n");
	
	s->tok = cursor;


#line 2259 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy273;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy276;
			default:	goto yy271;
			}
yy271:
			++YYCURSOR;
#line 510 "txt2bin.re"
			{ goto s_err; }
#line 2283 "txt2bin.cpp"
yy273:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy273;
			default:	goto yy275;
			}
yy275:
#line 508 "txt2bin.re"
			{ goto s_16; }
#line 2296 "txt2bin.cpp"
yy276:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy276;
			default:	goto yy278;
			}
yy278:
#line 509 "txt2bin.re"
			{ item.cpu = add_number(s->tok, cursor); goto s_17; }
#line 2317 "txt2bin.cpp"
		}
#line 511 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_17:
	state = 17;
	// printf("Entered s_17\n");
	

#line 2329 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy283;
			case '\n':	goto yy286;
			case '\r':	goto yy288;
			case 'n':	goto yy289;
			default:	goto yy281;
			}
yy281:
			++YYCURSOR;
yy282:
#line 523 "txt2bin.re"
			{ goto s_err; }
#line 2347 "txt2bin.cpp"
yy283:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy283;
			default:	goto yy285;
			}
yy285:
#line 520 "txt2bin.re"
			{ goto s_17; }
#line 2360 "txt2bin.cpp"
yy286:
			++YYCURSOR;
#line 522 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2365 "txt2bin.cpp"
yy288:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy286;
			default:	goto yy282;
			}
yy289:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case 'i':	goto yy290;
			default:	goto yy282;
			}
yy290:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'c':	goto yy292;
			default:	goto yy291;
			}
yy291:
			YYCURSOR = YYMARKER;
			goto yy282;
yy292:
			++YYCURSOR;
#line 521 "txt2bin.re"
			{ goto s_18; }
#line 2391 "txt2bin.cpp"
		}
#line 524 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_18:
	state = 18;
	// printf("Entered s_18\n");
	
	s->tok = cursor;


#line 2405 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy298;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy301;
			default:	goto yy296;
			}
yy296:
			++YYCURSOR;
#line 537 "txt2bin.re"
			{ goto s_err; }
#line 2429 "txt2bin.cpp"
yy298:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy298;
			default:	goto yy300;
			}
yy300:
#line 535 "txt2bin.re"
			{ goto s_18; }
#line 2442 "txt2bin.cpp"
yy301:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy301;
			default:	goto yy303;
			}
yy303:
#line 536 "txt2bin.re"
			{ item.nic = add_number(s->tok, cursor); goto s_19; }
#line 2463 "txt2bin.cpp"
		}
#line 538 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_19:
	state = 19;
	// printf("Entered s_19\n");


#line 2475 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy308;
			case '\n':	goto yy311;
			case '\r':	goto yy313;
			default:	goto yy306;
			}
yy306:
			++YYCURSOR;
yy307:
#line 549 "txt2bin.re"
			{ goto s_err; }
#line 2492 "txt2bin.cpp"
yy308:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy308;
			default:	goto yy310;
			}
yy310:
#line 547 "txt2bin.re"
			{ goto s_19; }
#line 2505 "txt2bin.cpp"
yy311:
			++YYCURSOR;
#line 548 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2510 "txt2bin.cpp"
yy313:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy311;
			default:	goto yy307;
			}
		}
#line 550 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_20:
	state = 20;
	// printf("Entered s_20\n");

	s->tok = cursor;


#line 2530 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy318;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy321;
			default:	goto yy316;
			}
yy316:
			++YYCURSOR;
#line 563 "txt2bin.re"
			{ goto s_err; }
#line 2554 "txt2bin.cpp"
yy318:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy318;
			default:	goto yy320;
			}
yy320:
#line 561 "txt2bin.re"
			{ goto s_20; }
#line 2567 "txt2bin.cpp"
yy321:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy321;
			default:	goto yy323;
			}
yy323:
#line 562 "txt2bin.re"
			{ s->rank = add_number(s->tok, cursor); s->curr_rank = s->rank; goto s_21; }
#line 2588 "txt2bin.cpp"
		}
#line 564 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_21:
	state = 21;
	// printf("Entered s_21\n");


#line 2600 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy328;
			case '{':	goto yy331;
			default:	goto yy326;
			}
yy326:
			++YYCURSOR;
#line 575 "txt2bin.re"
			{ goto s_err; }
#line 2615 "txt2bin.cpp"
yy328:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy328;
			default:	goto yy330;
			}
yy330:
#line 573 "txt2bin.re"
			{ goto s_21; }
#line 2628 "txt2bin.cpp"
yy331:
			++YYCURSOR;
#line 574 "txt2bin.re"
			{ goto s_0; }
#line 2633 "txt2bin.cpp"
		}
#line 576 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_22:
	state = 22;
	// printf("Entered s_22\n");

	s->tok = cursor;


#line 2647 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy337;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy340;
			default:	goto yy335;
			}
yy335:
			++YYCURSOR;
#line 589 "txt2bin.re"
			{ goto s_err; }
#line 2671 "txt2bin.cpp"
yy337:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '\t':
			case ' ':	goto yy337;
			default:	goto yy339;
			}
yy339:
#line 587 "txt2bin.re"
			{ goto s_22; }
#line 2684 "txt2bin.cpp"
yy340:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy340;
			default:	goto yy342;
			}
yy342:
#line 588 "txt2bin.re"
			{ s->num_ranks = add_number(s->tok, cursor); goto s_0; }
#line 2705 "txt2bin.cpp"
		}
#line 590 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_23:
	state = 23;
	// printf("Entered s_23\n");


#line 2717 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\n':	goto yy347;
			case '\r':	goto yy349;
			default:	goto yy345;
			}
yy345:
			++YYCURSOR;
yy346:
#line 600 "txt2bin.re"
			{ goto s_23; }
#line 2732 "txt2bin.cpp"
yy347:
			++YYCURSOR;
#line 599 "txt2bin.re"
			{ s->line++; continue;  }
#line 2737 "txt2bin.cpp"
yy349:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy347;
			default:	goto yy346;
			}
		}
#line 601 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_24:
	state = 24;
	// printf("Entered s_24\n");


#line 2755 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
			case '\n':	goto yy354;
			case '\r':	goto yy356;
			case '*':	goto yy357;
			default:	goto yy352;
			}
yy352:
			++YYCURSOR;
yy353:
#line 612 "txt2bin.re"
			{ goto s_24; }
#line 2771 "txt2bin.cpp"
yy354:
			++YYCURSOR;
#line 611 "txt2bin.re"
			{ s->line++; goto s_24;  }
#line 2776 "txt2bin.cpp"
yy356:
			yych = *++YYCURSOR;
			switch (yych) {
			case '\n':	goto yy354;
			default:	goto yy353;
			}
yy357:
			yych = *++YYCURSOR;
			switch (yych) {
			case '/':	goto yy358;
			default:	goto yy353;
			}
yy358:
			++YYCURSOR;
#line 610 "txt2bin.re"
			{ continue; }
#line 2793 "txt2bin.cpp"
		}
#line 613 "txt2bin.re"


	assert(0==1); //We should never reach this line
	
s_err:

	fprintf(stderr, "Error in line %i:\n", s->line);
	
	uchar* nlbef = s->bot;
	uchar* nlaft = s->lim;
	// find the last newline before the error
	uchar* c = cursor-2;
	while (c>s->bot) {
		c--;
		if (*c == '\n') {
			nlbef = c;
			break;
		}
	}
	// find the next newline after the error
	c = cursor-2;
	while (c<s->lim) {
		c++;
		if (*c == '\n') {
			nlaft = c;
			break;
		}
	}

	for (uchar* c = nlbef+1; c<nlaft; c++) {
		fprintf(stderr, "%c", *c);
	}
	fprintf(stderr, "\n");

	for (int cnt=0; cnt<(cursor-2)-nlbef; cnt++) {
		fprintf(stderr, " ");
	}
	fprintf(stderr, "^\n");


	switch(state) {
		case 0:
			fprintf(stderr,"Expected: \"rank\", \"num_ranks\", \"calc\", \"send\", \"recv\", an identifier, \"}\" or \"\\n\"\n");
			break;
		case 1:
			fprintf(stderr,"Expected: \":\", \"requires\" or \"irequires\"\n");
			break;
		case 2:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 3:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 4:
			fprintf(stderr,"Expected: \"calc\", \"send\" or \"recv\"\n");
			break;
		case 5:
			fprintf(stderr,"Expected: an identifier\n");
			break;
		case 6:
			fprintf(stderr,"Expected: \"\\n\"\n");
			break;
		case 7:
			fprintf(stderr,"Expected: \"cpu\" or \"\\n\"\n");
			break;
		case 8:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 9:
			fprintf(stderr,"Expected: \"\\n\"\n");
			break;
		case 10:
			fprintf(stderr,"Expected: \"b\"\n");
			break;
		case 11:
			if (item.type == SendOp) fprintf(stderr,"Expected: \"to\"\n");
			else if (item.type == RecvOp) fprintf(stderr,"Expected: \"from\"\n");
			else fprintf(stderr,"Expected: \"to\" or \"from\"\n");
			break;
		case 12:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 13:
			fprintf(stderr,"Expected: \"tag\", \"cpu\", \"nic\" or \"\\n\"\n");
			break;
		case 14:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 15:
			fprintf(stderr,"Expected: \"cpu\", \"nic\" or \"\\n\"\n");
			break;
		case 16:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 17:
			fprintf(stderr,"Expected: \"nic\" or \"\\n\"\n");
			break;
		case 18:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 19:
			fprintf(stderr,"Expected: \"\\n\"\n");
			break;
		case 20:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 21:
			fprintf(stderr,"Expected: \"{\"\n");
			break;
		case 22:
			fprintf(stderr,"Expected: an integer\n");
			break;
	}
	
	if (*(cursor-1) == '\n') {
		fprintf(stderr, "Instead the schedule contained: \"\\n\"\n");
	}
	else {
		fprintf(stderr, "Instead the schedule contained: \"%c\"\n", *(cursor-1));
	}


	
	exit(EXIT_FAILURE);

}
}

int main(int argc, char **argv){
    
	Scanner in;
	int lastprogress = 0;

	if (cmdline_parser(argc, argv, &args_info) != 0) {
		fprintf(stderr, "Couldn't parse command line arguments!\n");
		exit(EXIT_FAILURE);
	}

    memset((char*) &in, 0, sizeof(in));
   	in.fd = fopen(args_info.input_arg, "r");
	if (in.fd == NULL) {
		fprintf(stderr, "Couldn't open input file %s!\n", args_info.input_arg);
		exit(EXIT_FAILURE);
	}
	in.idtbl = new std::map<std::string, goalop_t>;
    
	uint32_t numranks = -1;

	while (true) {
		
		in.schedule = new Goal;
		
		scan(&in);

		if (in.num_ranks < 1) {
			fprintf(stderr, "Parse error: Number of Ranks undefined\n");
			exit(EXIT_FAILURE);
		}

		in.idtbl->clear();

		in.schedule->SetRank(in.curr_rank);
		in.schedule->SetNumRanks(in.num_ranks);
		in.schedule->SerializeSchedule(args_info.output_arg);
		delete in.schedule;
		int newprogress = round((((double) in.curr_rank) / in.num_ranks)*100);
		if (args_info.progress_given && (newprogress > lastprogress) ) {
			lastprogress = newprogress;
			printf("Progress %i%% - parsed schedule %i/%i\n", lastprogress, in.curr_rank, in.num_ranks);
		}
		if (in.curr_rank+1 == in.num_ranks) break;
	}
	
	free(in.bot);
	exit(EXIT_SUCCESS);
}
